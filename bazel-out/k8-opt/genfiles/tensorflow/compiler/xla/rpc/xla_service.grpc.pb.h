// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: tensorflow/compiler/xla/rpc/xla_service.proto
// Original file comments:
// Copyright 2018 The TensorFlow Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================
//
// XLA service API.
//
// Users 1) build up computations and 2) create allocations via this API.
// Computations are composed of data flowing between arbitrarily-sized
// vector-oriented operations.
//
// Users build up computations using a ComputationHandle, and talk about
// allocations using GlobalDataHandles.
//
// There are currently no checkpointing capabilities or distribution/replication
// guarantees. The service runs on a single machine (e.g. one task) and that is
// its failure domain.
//
// Canonical example of "alpha * X + Y":
// * Make a computation.
// * Add alpha and X and Y as parameters.
// * Request the multiplication of alpha and X.
// * Request the addition of that result and Y.
//
// Then, pass the computation and appropriately shaped inputs to the XLA
// service's Execute method, which provides a result as a GlobalDataHandle.
//
// All data in XLA computations are conceptually immutable.
//
// Note: this API is subject to change / refinement over time -- use the
// provided client libraries to insulate code from changes to this service API.
//
#ifndef GRPC_tensorflow_2fcompiler_2fxla_2frpc_2fxla_5fservice_2eproto__INCLUDED
#define GRPC_tensorflow_2fcompiler_2fxla_2frpc_2fxla_5fservice_2eproto__INCLUDED

#include "tensorflow/compiler/xla/rpc/xla_service.pb.h"

#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace xla {


namespace grpc {

class XlaService final {
 public:
  static constexpr char const* service_full_name() {
    return "xla.XlaService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Unregisters a global allocation.
    //
    // If the handle given is not currently allocated, a NOT_FOUND status is
    // returned.
    virtual ::grpc::Status Unregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::xla::UnregisterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>> AsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>>(AsyncUnregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>> PrepareAsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>>(PrepareAsyncUnregisterRaw(context, request, cq));
    }
    // Deconstructs a tuple. Returns a newly created GlobalDataHandle for each
    // element in the tuple.
    virtual ::grpc::Status DeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::xla::DeconstructTupleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>> AsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>>(AsyncDeconstructTupleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>> PrepareAsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>>(PrepareAsyncDeconstructTupleRaw(context, request, cq));
    }
    // Unpack requests that a global data handle, with a tuple shape, has global
    // data handles created for each of its constituent members. This is the
    // equivalent of the "destructuring assignment" present in various programming
    // languages.
    virtual ::grpc::Status Unpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::xla::UnpackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>> AsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>>(AsyncUnpackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>> PrepareAsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>>(PrepareAsyncUnpackRaw(context, request, cq));
    }
    // Requests the shape of the referenced global data.
    virtual ::grpc::Status GetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::xla::GetShapeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>> AsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>>(AsyncGetShapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>> PrepareAsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>>(PrepareAsyncGetShapeRaw(context, request, cq));
    }
    // Requests the statistics of the given computation.
    virtual ::grpc::Status GetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::xla::ComputationStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>> AsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>>(AsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>> PrepareAsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>>(PrepareAsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    // Loads a variable number of values with a given element type from ColumnIO.
    virtual ::grpc::Status LoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::xla::LoadDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>> AsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>>(AsyncLoadDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>> PrepareAsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>>(PrepareAsyncLoadDataRaw(context, request, cq));
    }
    // Transfers the given global data to the client in the form of a Literal.
    virtual ::grpc::Status TransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::xla::TransferToClientResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>> AsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>>(AsyncTransferToClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>> PrepareAsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>>(PrepareAsyncTransferToClientRaw(context, request, cq));
    }
    // Transfers the given literal to the server to be stored in a global
    // allocation, which is returned.
    virtual ::grpc::Status TransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::xla::TransferToServerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>> AsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>>(AsyncTransferToServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>> PrepareAsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>>(PrepareAsyncTransferToServerRaw(context, request, cq));
    }
    // Transfers the given literal to the Infeed buffer of the device.
    virtual ::grpc::Status TransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::xla::TransferToInfeedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>> AsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>>(AsyncTransferToInfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>> PrepareAsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>>(PrepareAsyncTransferToInfeedRaw(context, request, cq));
    }
    // Transferred literal from the Outfeed buffer of the device.
    virtual ::grpc::Status TransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::xla::TransferFromOutfeedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>> AsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>>(AsyncTransferFromOutfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>> PrepareAsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>>(PrepareAsyncTransferFromOutfeedRaw(context, request, cq));
    }
    // Resets the device, clearing all existing state on the device.
    virtual ::grpc::Status ResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::xla::ResetDeviceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>> AsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>>(AsyncResetDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>> PrepareAsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>>(PrepareAsyncResetDeviceRaw(context, request, cq));
    }
    // Computes the value of a constant expression. The request contains the
    // computation graph for the constant expression.
    virtual ::grpc::Status ComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::xla::ComputeConstantResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>> AsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>>(AsyncComputeConstantGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>> PrepareAsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>>(PrepareAsyncComputeConstantGraphRaw(context, request, cq));
    }
    // Requests one or more device handles from the target. The returned device
    // handles can be used to specify the device on which to execute computations
    // or transfer data.
    virtual ::grpc::Status GetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::xla::GetDeviceHandlesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>> AsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>>(AsyncGetDeviceHandlesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>> PrepareAsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>>(PrepareAsyncGetDeviceHandlesRaw(context, request, cq));
    }
    // Creates a channel handle that can be used to transfer data between
    // two computations via a pair of Send and Recv instructions.
    virtual ::grpc::Status CreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::xla::CreateChannelHandleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>> AsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>>(AsyncCreateChannelHandleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>> PrepareAsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>>(PrepareAsyncCreateChannelHandleRaw(context, request, cq));
    }
    // Invokes the provided computation with the provided global data passed as
    // immutable arguments. The request contains the whole computation graph.
    // Returns global data output and execution timing.
    virtual ::grpc::Status ExecuteGraph(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::xla::ExecuteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>> AsyncExecuteGraph(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>>(AsyncExecuteGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>> PrepareAsyncExecuteGraph(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>>(PrepareAsyncExecuteGraphRaw(context, request, cq));
    }
    // Invokes the provided list of computations in parallel with the provided
    // global data for each computation. Returns a list of global data output and
    // execution timing.
    virtual ::grpc::Status ExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::xla::ExecuteParallelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>> AsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>>(AsyncExecuteGraphParallelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>> PrepareAsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>>(PrepareAsyncExecuteGraphParallelRaw(context, request, cq));
    }
    // Waits until the given execution (aysnchronously launched) is complete, and
    // returns the global data output.
    virtual ::grpc::Status WaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::xla::WaitForExecutionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>> AsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>>(AsyncWaitForExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>> PrepareAsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>>(PrepareAsyncWaitForExecutionRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>* AsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>* PrepareAsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>* AsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>* PrepareAsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>* AsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>* PrepareAsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>* AsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>* PrepareAsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>* AsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>* PrepareAsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>* AsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>* PrepareAsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>* AsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>* PrepareAsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>* AsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>* PrepareAsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>* AsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>* PrepareAsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>* AsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>* PrepareAsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>* AsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>* PrepareAsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>* AsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>* PrepareAsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>* AsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>* PrepareAsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>* AsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>* PrepareAsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>* AsyncExecuteGraphRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>* PrepareAsyncExecuteGraphRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>* AsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>* PrepareAsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>* AsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>* PrepareAsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Unregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::xla::UnregisterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>> AsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>>(AsyncUnregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>> PrepareAsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>>(PrepareAsyncUnregisterRaw(context, request, cq));
    }
    ::grpc::Status DeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::xla::DeconstructTupleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>> AsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>>(AsyncDeconstructTupleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>> PrepareAsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>>(PrepareAsyncDeconstructTupleRaw(context, request, cq));
    }
    ::grpc::Status Unpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::xla::UnpackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>> AsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>>(AsyncUnpackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>> PrepareAsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>>(PrepareAsyncUnpackRaw(context, request, cq));
    }
    ::grpc::Status GetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::xla::GetShapeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>> AsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>>(AsyncGetShapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>> PrepareAsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>>(PrepareAsyncGetShapeRaw(context, request, cq));
    }
    ::grpc::Status GetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::xla::ComputationStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>> AsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>>(AsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>> PrepareAsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>>(PrepareAsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    ::grpc::Status LoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::xla::LoadDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>> AsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>>(AsyncLoadDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>> PrepareAsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>>(PrepareAsyncLoadDataRaw(context, request, cq));
    }
    ::grpc::Status TransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::xla::TransferToClientResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>> AsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>>(AsyncTransferToClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>> PrepareAsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>>(PrepareAsyncTransferToClientRaw(context, request, cq));
    }
    ::grpc::Status TransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::xla::TransferToServerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>> AsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>>(AsyncTransferToServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>> PrepareAsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>>(PrepareAsyncTransferToServerRaw(context, request, cq));
    }
    ::grpc::Status TransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::xla::TransferToInfeedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>> AsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>>(AsyncTransferToInfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>> PrepareAsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>>(PrepareAsyncTransferToInfeedRaw(context, request, cq));
    }
    ::grpc::Status TransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::xla::TransferFromOutfeedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>> AsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>>(AsyncTransferFromOutfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>> PrepareAsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>>(PrepareAsyncTransferFromOutfeedRaw(context, request, cq));
    }
    ::grpc::Status ResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::xla::ResetDeviceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>> AsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>>(AsyncResetDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>> PrepareAsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>>(PrepareAsyncResetDeviceRaw(context, request, cq));
    }
    ::grpc::Status ComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::xla::ComputeConstantResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>> AsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>>(AsyncComputeConstantGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>> PrepareAsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>>(PrepareAsyncComputeConstantGraphRaw(context, request, cq));
    }
    ::grpc::Status GetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::xla::GetDeviceHandlesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>> AsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>>(AsyncGetDeviceHandlesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>> PrepareAsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>>(PrepareAsyncGetDeviceHandlesRaw(context, request, cq));
    }
    ::grpc::Status CreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::xla::CreateChannelHandleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>> AsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>>(AsyncCreateChannelHandleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>> PrepareAsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>>(PrepareAsyncCreateChannelHandleRaw(context, request, cq));
    }
    ::grpc::Status ExecuteGraph(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::xla::ExecuteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>> AsyncExecuteGraph(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>>(AsyncExecuteGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>> PrepareAsyncExecuteGraph(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>>(PrepareAsyncExecuteGraphRaw(context, request, cq));
    }
    ::grpc::Status ExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::xla::ExecuteParallelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>> AsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>>(AsyncExecuteGraphParallelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>> PrepareAsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>>(PrepareAsyncExecuteGraphParallelRaw(context, request, cq));
    }
    ::grpc::Status WaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::xla::WaitForExecutionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>> AsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>>(AsyncWaitForExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>> PrepareAsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>>(PrepareAsyncWaitForExecutionRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>* AsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>* PrepareAsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>* AsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>* PrepareAsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>* AsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>* PrepareAsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>* AsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>* PrepareAsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>* AsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>* PrepareAsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>* AsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>* PrepareAsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>* AsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>* PrepareAsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>* AsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>* PrepareAsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>* AsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>* PrepareAsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>* AsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>* PrepareAsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>* AsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>* PrepareAsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>* AsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>* PrepareAsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>* AsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>* PrepareAsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>* AsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>* PrepareAsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>* AsyncExecuteGraphRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>* PrepareAsyncExecuteGraphRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>* AsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>* PrepareAsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>* AsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>* PrepareAsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Unregister_;
    const ::grpc::internal::RpcMethod rpcmethod_DeconstructTuple_;
    const ::grpc::internal::RpcMethod rpcmethod_Unpack_;
    const ::grpc::internal::RpcMethod rpcmethod_GetShape_;
    const ::grpc::internal::RpcMethod rpcmethod_GetComputationGraphStats_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadData_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferToClient_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferToServer_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferToInfeed_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferFromOutfeed_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_ComputeConstantGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDeviceHandles_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateChannelHandle_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteGraphParallel_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitForExecution_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Unregisters a global allocation.
    //
    // If the handle given is not currently allocated, a NOT_FOUND status is
    // returned.
    virtual ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response);
    // Deconstructs a tuple. Returns a newly created GlobalDataHandle for each
    // element in the tuple.
    virtual ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response);
    // Unpack requests that a global data handle, with a tuple shape, has global
    // data handles created for each of its constituent members. This is the
    // equivalent of the "destructuring assignment" present in various programming
    // languages.
    virtual ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response);
    // Requests the shape of the referenced global data.
    virtual ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response);
    // Requests the statistics of the given computation.
    virtual ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response);
    // Loads a variable number of values with a given element type from ColumnIO.
    virtual ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response);
    // Transfers the given global data to the client in the form of a Literal.
    virtual ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response);
    // Transfers the given literal to the server to be stored in a global
    // allocation, which is returned.
    virtual ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response);
    // Transfers the given literal to the Infeed buffer of the device.
    virtual ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response);
    // Transferred literal from the Outfeed buffer of the device.
    virtual ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response);
    // Resets the device, clearing all existing state on the device.
    virtual ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response);
    // Computes the value of a constant expression. The request contains the
    // computation graph for the constant expression.
    virtual ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response);
    // Requests one or more device handles from the target. The returned device
    // handles can be used to specify the device on which to execute computations
    // or transfer data.
    virtual ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response);
    // Creates a channel handle that can be used to transfer data between
    // two computations via a pair of Send and Recv instructions.
    virtual ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response);
    // Invokes the provided computation with the provided global data passed as
    // immutable arguments. The request contains the whole computation graph.
    // Returns global data output and execution timing.
    virtual ::grpc::Status ExecuteGraph(::grpc::ServerContext* context, const ::xla::ExecuteGraphRequest* request, ::xla::ExecuteResponse* response);
    // Invokes the provided list of computations in parallel with the provided
    // global data for each computation. Returns a list of global data output and
    // execution timing.
    virtual ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response);
    // Waits until the given execution (aysnchronously launched) is complete, and
    // returns the global data output.
    virtual ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Unregister() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregister(::grpc::ServerContext* context, ::xla::UnregisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::UnregisterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeconstructTuple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeconstructTuple() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DeconstructTuple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeconstructTuple(::grpc::ServerContext* context, ::xla::DeconstructTupleRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::DeconstructTupleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unpack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Unpack() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Unpack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnpack(::grpc::ServerContext* context, ::xla::UnpackRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::UnpackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetShape() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetShape(::grpc::ServerContext* context, ::xla::GetShapeRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::GetShapeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetComputationGraphStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetComputationGraphStats() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetComputationGraphStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetComputationGraphStats(::grpc::ServerContext* context, ::xla::ComputationGraphStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ComputationStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_LoadData() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_LoadData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadData(::grpc::ServerContext* context, ::xla::LoadDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::LoadDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferToClient() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_TransferToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToClient(::grpc::ServerContext* context, ::xla::TransferToClientRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferToClientResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferToServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferToServer() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_TransferToServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToServer(::grpc::ServerContext* context, ::xla::TransferToServerRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferToServerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferToInfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferToInfeed() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_TransferToInfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToInfeed(::grpc::ServerContext* context, ::xla::TransferToInfeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferToInfeedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferFromOutfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferFromOutfeed() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_TransferFromOutfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferFromOutfeed(::grpc::ServerContext* context, ::xla::TransferFromOutfeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferFromOutfeedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ResetDevice() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ResetDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetDevice(::grpc::ServerContext* context, ::xla::ResetDeviceRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ResetDeviceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ComputeConstantGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ComputeConstantGraph() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ComputeConstantGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestComputeConstantGraph(::grpc::ServerContext* context, ::xla::ComputeConstantGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ComputeConstantResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDeviceHandles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetDeviceHandles() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetDeviceHandles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDeviceHandles(::grpc::ServerContext* context, ::xla::GetDeviceHandlesRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::GetDeviceHandlesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateChannelHandle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateChannelHandle() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_CreateChannelHandle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateChannelHandle(::grpc::ServerContext* context, ::xla::CreateChannelHandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::CreateChannelHandleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ExecuteGraph() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ExecuteGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteGraph(::grpc::ServerContext* context, const ::xla::ExecuteGraphRequest* request, ::xla::ExecuteResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteGraph(::grpc::ServerContext* context, ::xla::ExecuteGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ExecuteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteGraphParallel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ExecuteGraphParallel() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_ExecuteGraphParallel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteGraphParallel(::grpc::ServerContext* context, ::xla::ExecuteGraphParallelRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ExecuteParallelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitForExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WaitForExecution() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_WaitForExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitForExecution(::grpc::ServerContext* context, ::xla::WaitForExecutionRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::WaitForExecutionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Unregister<WithAsyncMethod_DeconstructTuple<WithAsyncMethod_Unpack<WithAsyncMethod_GetShape<WithAsyncMethod_GetComputationGraphStats<WithAsyncMethod_LoadData<WithAsyncMethod_TransferToClient<WithAsyncMethod_TransferToServer<WithAsyncMethod_TransferToInfeed<WithAsyncMethod_TransferFromOutfeed<WithAsyncMethod_ResetDevice<WithAsyncMethod_ComputeConstantGraph<WithAsyncMethod_GetDeviceHandles<WithAsyncMethod_CreateChannelHandle<WithAsyncMethod_ExecuteGraph<WithAsyncMethod_ExecuteGraphParallel<WithAsyncMethod_WaitForExecution<Service > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Unregister() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeconstructTuple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeconstructTuple() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DeconstructTuple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unpack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Unpack() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Unpack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetShape() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetComputationGraphStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetComputationGraphStats() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetComputationGraphStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_LoadData() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_LoadData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferToClient() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_TransferToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferToServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferToServer() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_TransferToServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferToInfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferToInfeed() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_TransferToInfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferFromOutfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferFromOutfeed() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_TransferFromOutfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ResetDevice() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ResetDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ComputeConstantGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ComputeConstantGraph() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ComputeConstantGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDeviceHandles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetDeviceHandles() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetDeviceHandles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateChannelHandle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateChannelHandle() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_CreateChannelHandle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ExecuteGraph() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ExecuteGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteGraph(::grpc::ServerContext* context, const ::xla::ExecuteGraphRequest* request, ::xla::ExecuteResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteGraphParallel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ExecuteGraphParallel() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_ExecuteGraphParallel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitForExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WaitForExecution() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_WaitForExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Unregister() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::UnregisterRequest, ::xla::UnregisterResponse>(std::bind(&WithStreamedUnaryMethod_Unregister<BaseClass>::StreamedUnregister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnregister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::UnregisterRequest,::xla::UnregisterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeconstructTuple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeconstructTuple() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::DeconstructTupleRequest, ::xla::DeconstructTupleResponse>(std::bind(&WithStreamedUnaryMethod_DeconstructTuple<BaseClass>::StreamedDeconstructTuple, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeconstructTuple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeconstructTuple(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::DeconstructTupleRequest,::xla::DeconstructTupleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unpack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Unpack() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::UnpackRequest, ::xla::UnpackResponse>(std::bind(&WithStreamedUnaryMethod_Unpack<BaseClass>::StreamedUnpack, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unpack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnpack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::UnpackRequest,::xla::UnpackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetShape() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::GetShapeRequest, ::xla::GetShapeResponse>(std::bind(&WithStreamedUnaryMethod_GetShape<BaseClass>::StreamedGetShape, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetShape(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::GetShapeRequest,::xla::GetShapeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetComputationGraphStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetComputationGraphStats() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ComputationGraphStatsRequest, ::xla::ComputationStatsResponse>(std::bind(&WithStreamedUnaryMethod_GetComputationGraphStats<BaseClass>::StreamedGetComputationGraphStats, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetComputationGraphStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetComputationGraphStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ComputationGraphStatsRequest,::xla::ComputationStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_LoadData() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::LoadDataRequest, ::xla::LoadDataResponse>(std::bind(&WithStreamedUnaryMethod_LoadData<BaseClass>::StreamedLoadData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_LoadData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::LoadDataRequest,::xla::LoadDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferToClient() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferToClientRequest, ::xla::TransferToClientResponse>(std::bind(&WithStreamedUnaryMethod_TransferToClient<BaseClass>::StreamedTransferToClient, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferToClient(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferToClientRequest,::xla::TransferToClientResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferToServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferToServer() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferToServerRequest, ::xla::TransferToServerResponse>(std::bind(&WithStreamedUnaryMethod_TransferToServer<BaseClass>::StreamedTransferToServer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferToServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferToServer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferToServerRequest,::xla::TransferToServerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferToInfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferToInfeed() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferToInfeedRequest, ::xla::TransferToInfeedResponse>(std::bind(&WithStreamedUnaryMethod_TransferToInfeed<BaseClass>::StreamedTransferToInfeed, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferToInfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferToInfeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferToInfeedRequest,::xla::TransferToInfeedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferFromOutfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferFromOutfeed() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferFromOutfeedRequest, ::xla::TransferFromOutfeedResponse>(std::bind(&WithStreamedUnaryMethod_TransferFromOutfeed<BaseClass>::StreamedTransferFromOutfeed, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferFromOutfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferFromOutfeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferFromOutfeedRequest,::xla::TransferFromOutfeedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ResetDevice() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ResetDeviceRequest, ::xla::ResetDeviceResponse>(std::bind(&WithStreamedUnaryMethod_ResetDevice<BaseClass>::StreamedResetDevice, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ResetDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ResetDeviceRequest,::xla::ResetDeviceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ComputeConstantGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ComputeConstantGraph() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ComputeConstantGraphRequest, ::xla::ComputeConstantResponse>(std::bind(&WithStreamedUnaryMethod_ComputeConstantGraph<BaseClass>::StreamedComputeConstantGraph, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ComputeConstantGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedComputeConstantGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ComputeConstantGraphRequest,::xla::ComputeConstantResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDeviceHandles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetDeviceHandles() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::GetDeviceHandlesRequest, ::xla::GetDeviceHandlesResponse>(std::bind(&WithStreamedUnaryMethod_GetDeviceHandles<BaseClass>::StreamedGetDeviceHandles, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDeviceHandles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDeviceHandles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::GetDeviceHandlesRequest,::xla::GetDeviceHandlesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateChannelHandle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateChannelHandle() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::CreateChannelHandleRequest, ::xla::CreateChannelHandleResponse>(std::bind(&WithStreamedUnaryMethod_CreateChannelHandle<BaseClass>::StreamedCreateChannelHandle, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateChannelHandle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateChannelHandle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::CreateChannelHandleRequest,::xla::CreateChannelHandleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ExecuteGraph() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ExecuteGraphRequest, ::xla::ExecuteResponse>(std::bind(&WithStreamedUnaryMethod_ExecuteGraph<BaseClass>::StreamedExecuteGraph, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ExecuteGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteGraph(::grpc::ServerContext* context, const ::xla::ExecuteGraphRequest* request, ::xla::ExecuteResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ExecuteGraphRequest,::xla::ExecuteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteGraphParallel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ExecuteGraphParallel() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ExecuteGraphParallelRequest, ::xla::ExecuteParallelResponse>(std::bind(&WithStreamedUnaryMethod_ExecuteGraphParallel<BaseClass>::StreamedExecuteGraphParallel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ExecuteGraphParallel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteGraphParallel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ExecuteGraphParallelRequest,::xla::ExecuteParallelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitForExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WaitForExecution() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::WaitForExecutionRequest, ::xla::WaitForExecutionResponse>(std::bind(&WithStreamedUnaryMethod_WaitForExecution<BaseClass>::StreamedWaitForExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WaitForExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitForExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::WaitForExecutionRequest,::xla::WaitForExecutionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Unregister<WithStreamedUnaryMethod_DeconstructTuple<WithStreamedUnaryMethod_Unpack<WithStreamedUnaryMethod_GetShape<WithStreamedUnaryMethod_GetComputationGraphStats<WithStreamedUnaryMethod_LoadData<WithStreamedUnaryMethod_TransferToClient<WithStreamedUnaryMethod_TransferToServer<WithStreamedUnaryMethod_TransferToInfeed<WithStreamedUnaryMethod_TransferFromOutfeed<WithStreamedUnaryMethod_ResetDevice<WithStreamedUnaryMethod_ComputeConstantGraph<WithStreamedUnaryMethod_GetDeviceHandles<WithStreamedUnaryMethod_CreateChannelHandle<WithStreamedUnaryMethod_ExecuteGraph<WithStreamedUnaryMethod_ExecuteGraphParallel<WithStreamedUnaryMethod_WaitForExecution<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Unregister<WithStreamedUnaryMethod_DeconstructTuple<WithStreamedUnaryMethod_Unpack<WithStreamedUnaryMethod_GetShape<WithStreamedUnaryMethod_GetComputationGraphStats<WithStreamedUnaryMethod_LoadData<WithStreamedUnaryMethod_TransferToClient<WithStreamedUnaryMethod_TransferToServer<WithStreamedUnaryMethod_TransferToInfeed<WithStreamedUnaryMethod_TransferFromOutfeed<WithStreamedUnaryMethod_ResetDevice<WithStreamedUnaryMethod_ComputeConstantGraph<WithStreamedUnaryMethod_GetDeviceHandles<WithStreamedUnaryMethod_CreateChannelHandle<WithStreamedUnaryMethod_ExecuteGraph<WithStreamedUnaryMethod_ExecuteGraphParallel<WithStreamedUnaryMethod_WaitForExecution<Service > > > > > > > > > > > > > > > > > StreamedService;
};
// ///////////////////////
// Global data requests

}  // namespace grpc

}  // namespace xla


#endif  // GRPC_tensorflow_2fcompiler_2fxla_2frpc_2fxla_5fservice_2eproto__INCLUDED
